<!DOCTYPE html>
<html lang="en" data-theme="fantasy">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tambola Game - Player</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.10.2/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .ticket-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            border: 1px solid #ccc;
            margin-bottom: 1rem;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        .ticket-cell {
            @apply border border-base-300 aspect-square flex justify-center items-center text-sm sm:text-base font-semibold;
            min-height: 40px;
        }
        .ticket-cell.number {
            @apply bg-base-100 cursor-pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .ticket-cell.number.marked {
            @apply bg-accent text-accent-content line-through scale-95;
        }
        .ticket-cell.number.drawn-highlight { /* For newly drawn number on ticket */
            @apply ring-2 ring-secondary ring-offset-2;
        }
        .ticket-cell.blank {
            @apply bg-base-200;
        }
        .floating-nav-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        .tab-ticket.active {
            @apply tab-active font-bold;
        }
        /* Toast notification styles */
        .toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast-message {
            @apply alert shadow-lg text-sm;
            opacity: 0;
            transform: translateX(100%);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        .toast-message.show {
            opacity: 1;
            transform: translateX(0);
        }
        main { padding-bottom: 80px; /* Space for floating nav */ }
    </style>
</head>
<body class="bg-base-200 min-h-screen flex flex-col">

    <div id="toastContainer" class="toast-container"></div>

    <div class="drawer lg:drawer-open">
        <input id="player-drawer" type="checkbox" class="drawer-toggle" />
        
        <div class="drawer-content flex flex-col">
            <div class="w-full navbar bg-base-300 sticky top-0 z-50 shadow-md">
                <div class="flex-none lg:hidden">
                    <label for="player-drawer" aria-label="open sidebar" class="btn btn-square btn-ghost">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="inline-block w-6 h-6 stroke-current"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
                    </label>
                </div>
                <div class="flex-1 px-2 mx-2 font-bold text-xl">Tambola Game <span id="roomDisplay" class="text-sm ml-2 badge badge-neutral hidden"></span></div>
                <div class="flex-none hidden lg:block">
                    <ul class="menu menu-horizontal">
                         <li><a href="#ticketSection" class="font-semibold">My Tickets</a></li>
                         <li><a href="#drawnNumbersSection" class="font-semibold">Game Board</a></li>
                         <li><a href="/admin" class="font-semibold" target="_blank">Admin Panel</a></li>
                    </ul>
                </div>
            </div>

            <main class="container mx-auto p-4 flex-grow">
                
                <section id="joinGameSection" class="my-8 p-6 bg-base-100 rounded-box shadow-lg max-w-md mx-auto">
                    <h2 class="text-2xl font-semibold mb-4 text-center">Join Tambola Game</h2>
                    <div class="form-control mb-4">
                        <label class="label" for="playerNameInput"><span class="label-text">Your Name</span></label>
                        <input type="text" id="playerNameInput" placeholder="Enter your name" class="input input-bordered w-full" />
                    </div>
                    <div class="form-control mb-4">
                        <label class="label" for="roomIdInputPlayer"><span class="label-text">Room ID</span></label>
                        <input type="text" id="roomIdInputPlayer" placeholder="Enter Room ID from Admin" class="input input-bordered w-full" />
                    </div>
                    <button id="joinGameBtn" class="btn btn-primary btn-block" onclick="joinGame()">Join Game</button>
                    <p id="joinErrorText" class="text-error text-sm mt-2 text-center"></p>
                </section>

                <div id="gameAreaDisplay" class="hidden">
                    <div class="text-center mb-2">
                        <h1 class="text-3xl font-bold text-primary">Welcome, <span id="playerNameDisplay"></span>!</h1>
                        <p id="ticketStatusText" class="text-sm text-info-content min-h-[20px]"></p>
                    </div>

                    <section id="ticketSection" class="my-6">
                        <div class="flex justify-between items-center mb-2">
                            <h2 class="text-2xl font-semibold">Your Tickets</h2>
                            <button id="addTicketBtn" class="btn btn-sm btn-secondary" onclick="requestAnotherTicket()">Request New Ticket</button>
                        </div>
                        <div id="ticketTabsContainer" role="tablist" class="tabs tabs-lifted tabs-sm sm:tabs-md">
                            </div>
                        <div id="ticketGridsContainer" class="mt-1 p-2 sm:p-4 bg-base-100 rounded-box shadow-lg">
                            <p id="noTicketsText" class="text-center italic p-4">You have no tickets yet. Request one!</p>
                        </div>
                         <div class="form-control w-fit mt-4">
                            <label class="label cursor-pointer gap-2">
                                <span class="label-text">Auto-Mark Numbers</span> 
                                <input type="checkbox" id="autoMarkCheckbox" class="toggle toggle-primary" checked onchange="toggleAutoMark(this.checked)"/>
                            </label>
                        </div>
                    </section>

                    <section id="drawnNumbersSection" class="my-8">
                        <div id="latestNumberDisplay" class="text-center my-6 p-4 bg-base-100 rounded-box shadow max-w-xs mx-auto">
                            <h2 class="text-lg font-semibold mb-1">Last Number Drawn:</h2>
                            <p id="currentNumberPlayer" class="text-5xl font-bold text-secondary">-</p>
                        </div>
                        
                        <div class="max-w-3xl mx-auto">
                            <h3 class="text-xl font-semibold mb-2 text-center">All Drawn Numbers (<span id="drawnCountPlayer">0</span>/90):</h3>
                            <div id="drawnNumbersListPlayer" class="p-4 bg-base-100 rounded-box shadow min-h-[50px] flex flex-wrap gap-2 justify-center items-center">
                                 <span class="italic text-gray-500">Waiting for game to start...</span>
                            </div>
                        </div>
                    </section>
                    
                    <section id="claimPrizeSection" class="my-8 p-4 bg-base-100 rounded-box shadow-lg">
                        <h2 class="text-2xl font-semibold mb-4 text-center">Claim a Prize</h2>
                        <div class="form-control w-full max-w-xs mx-auto">
                            <label class="label"><span class="label-text">Select Prize:</span></label>
                            <select id="prizeTypeSelect" class="select select-bordered w-full">
                                </select>
                            <button id="submitClaimBtn" class="btn btn-accent mt-4 w-full" onclick="submitClaim()">Claim Selected Prize</button>
                        </div>
                        <div id="claimStatusMessage" class="mt-4 text-center font-medium"></div>
                    </section>

                    <section id="myClaimsListSection" class="my-8 p-4 bg-base-100 rounded-box shadow-lg">
                        <h2 class="text-2xl font-semibold mb-4 text-center">My Claims History</h2>
                        <div id="myClaimsList" class="max-h-60 overflow-y-auto">
                            <p class="italic text-gray-500 p-2">You haven't made any claims yet.</p>
                        </div>
                    </section>

                    <div id="gameStatusPlayer" class="text-center my-4 text-lg font-medium">
                        Status: <span id="statusTextPlayer">Not Started</span>
                    </div>
                    <div id="gameOverMessagePlayer" class="text-center my-4 text-2xl font-bold text-error hidden">GAME OVER!</div>
                </div>
            </main>
        </div> 
        
        <div class="drawer-side z-[60]">
            <label for="player-drawer" aria-label="close sidebar" class="drawer-overlay"></label> 
            <ul class="menu p-4 w-80 min-h-full bg-base-200">
                <li class="menu-title">Game Menu</li>
                <li><a href="#ticketSection" onclick="closeDrawerAndScroll('#ticketSection')">My Tickets</a></li>
                <li><a href="#drawnNumbersSection" onclick="closeDrawerAndScroll('#drawnNumbersSection')">Game Board</a></li>
                <li><a href="#claimPrizeSection" onclick="closeDrawerAndScroll('#claimPrizeSection')">Claim Prize</a></li>
                <li><a href="#myClaimsListSection" onclick="closeDrawerAndScroll('#myClaimsListSection')">My Claims</a></li>
                <li class="mt-auto"><div class="divider"></div></li>
                <li><a href="/admin" target="_blank">Admin Panel</a></li>
                 <li><a onclick="closeDrawer()">Close Menu</a></li>
            </ul>
        </div>
    </div>

    <div class="floating-nav-container btm-nav lg:hidden">
        <button id="floatTicketNav" class="text-primary" onclick="closeDrawerAndScroll('#ticketSection')">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 5v2m0 4v2m0 4v2M5 5a2 2 0 00-2 2v3a2 2 0 002 2h14a2 2 0 002-2v-3a2 2 0 00-2-2H5z"></path></svg>
            <span class="btm-nav-label">Tickets</span>
        </button>
        <button id="floatBoardNav" onclick="closeDrawerAndScroll('#drawnNumbersSection')">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
            <span class="btm-nav-label">Board</span>
        </button>
        <button id="floatClaimNav" onclick="closeDrawerAndScroll('#claimPrizeSection')">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            <span class="btm-nav-label">Claim</span>
        </button>
    </div>

    <script>
        // !!! IMPORTANT: Set your Render Backend URL here !!!
        const API_BASE_URL = 'https://tambola-backend.onrender.com'; 

        // DOM Elements
        const joinGameSection = document.getElementById('joinGameSection');
        const gameAreaDisplay = document.getElementById('gameAreaDisplay');
        const playerNameInput = document.getElementById('playerNameInput');
        const roomIdInputPlayer = document.getElementById('roomIdInputPlayer');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const joinErrorText = document.getElementById('joinErrorText');
        const roomDisplay = document.getElementById('roomDisplay');
        const playerNameDisplay = document.getElementById('playerNameDisplay');
        
        const ticketTabsContainer = document.getElementById('ticketTabsContainer');
        const ticketGridsContainer = document.getElementById('ticketGridsContainer');
        const noTicketsText = document.getElementById('noTicketsText');
        const addTicketBtn = document.getElementById('addTicketBtn');
        const ticketStatusText = document.getElementById('ticketStatusText');
        const autoMarkCheckbox = document.getElementById('autoMarkCheckbox');

        const latestNumberDisplay = document.getElementById('latestNumberDisplay');
        const currentNumberPlayerEl = document.getElementById('currentNumberPlayer');
        const drawnNumbersListPlayerEl = document.getElementById('drawnNumbersListPlayer');
        const drawnCountPlayerEl = document.getElementById('drawnCountPlayer');
        
        const prizeTypeSelect = document.getElementById('prizeTypeSelect');
        const submitClaimBtn = document.getElementById('submitClaimBtn');
        const claimStatusMessageEl = document.getElementById('claimStatusMessage');
        const myClaimsListEl = document.getElementById('myClaimsList');

        const statusTextPlayerEl = document.getElementById('statusTextPlayer');
        const gameOverMessagePlayerEl = document.getElementById('gameOverMessagePlayer');
        const toastContainer = document.getElementById('toastContainer');

        // Player & Game State
        let currentPlayerId = localStorage.getItem('tambolaPlayerId');
        let currentPlayerName = localStorage.getItem('tambolaPlayerName');
        let currentRoomId = localStorage.getItem('tambolaRoomId');
        let playerTickets = []; 
        let activeTicketIndex = 0;
        let isAutoMarkEnabled = true;
        let serverGameState = {}; 
        let pollingIntervalId = null;
        let lastKnownDrawnNumbersCount = 0;
        let isJoining = false; 
        let isRequestingTicket = false; 
        let isSubmittingClaim = false; 


        // Initialization
        window.onload = () => {
            if (!API_BASE_URL || API_BASE_URL === 'YOUR_RENDER_BACKEND_URL_HERE') { 
                alert("CRITICAL: API_BASE_URL is not set correctly in the frontend JavaScript. Please check index.html.");
                joinGameBtn.disabled = true;
                addTicketBtn.disabled = true;
                submitClaimBtn.disabled = true;
                showToast("Frontend configuration error: API_BASE_URL not set.", "error");
            }

            const urlParams = new URLSearchParams(window.location.search);
            const roomIdFromUrl = urlParams.get('roomId');
            if (roomIdFromUrl) {
                roomIdInputPlayer.value = roomIdFromUrl;
            }

            if (localStorage.getItem('tambolaAutoMark') !== null) {
                isAutoMarkEnabled = localStorage.getItem('tambolaAutoMark') === 'true';
                autoMarkCheckbox.checked = isAutoMarkEnabled;
            } else {
                 isAutoMarkEnabled = autoMarkCheckbox.checked; 
            }

            // Populate input fields if data exists in localStorage, but DO NOT auto-join
            if (currentPlayerName) {
                playerNameInput.value = currentPlayerName;
            }
            if (currentRoomId) {
                roomIdInputPlayer.value = currentRoomId;
            }

            // if (currentPlayerId && currentRoomId && currentPlayerName) {
            //     playerNameInput.value = currentPlayerName;
            //     roomIdInputPlayer.value = currentRoomId;
            //     // joinGame(true); // <-- THIS LINE CAUSED AUTO-JOIN, NOW COMMENTED OUT
            // }
        };
        
        function showToast(message, type = 'info') { 
            const toast = document.createElement('div');
            let alertClass = 'alert-info'; 
            if (type === 'success') alertClass = 'alert-success';
            else if (type === 'error') alertClass = 'alert-error';
            else if (type === 'warning') alertClass = 'alert-warning';
            
            toast.classList.add('toast-message', 'alert', alertClass); 
            toast.innerHTML = `<span>${message}</span>`;
            toastContainer.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 10);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 5000);
            }, 5000);
        }

        async function joinGame(isRejoin = false) { // isRejoin flag is now less critical here but kept for consistency
            if (isJoining) return; 
            isJoining = true;
            joinGameBtn.disabled = true; 
            joinGameBtn.classList.add('loading'); 

            const name = playerNameInput.value.trim();
            const roomId = roomIdInputPlayer.value.trim();
            joinErrorText.textContent = '';

            if (!name) {
                joinErrorText.textContent = "Player name is mandatory.";
                isJoining = false;
                joinGameBtn.disabled = false;
                joinGameBtn.classList.remove('loading');
                return;
            }
            if (!roomId) {
                joinErrorText.textContent = "Room ID is mandatory.";
                isJoining = false;
                joinGameBtn.disabled = false;
                joinGameBtn.classList.remove('loading');
                return;
            }

            // If it's not a programmatic rejoin attempt, ensure we use the latest localStorage or generate new ID
            const playerIdToSend = isRejoin ? currentPlayerId : (localStorage.getItem('tambolaPlayerId') || null);


            try {
                const response = await fetch(`${API_BASE_URL}/api/player/join-game`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        playerName: name, 
                        roomId: roomId, 
                        playerId: playerIdToSend 
                    }) 
                });

                if (!response.ok) {
                    let errorMsg = "Failed to join game. Server returned: " + response.status;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.message || errorMsg;
                    } catch (e) {
                        console.warn("Response from server on join error was not JSON. Status: " + response.status);
                        const textError = await response.text(); 
                        errorMsg = `Failed to join. Server status: ${response.status}. Response: ${textError.substring(0,100)}...`;
                    }
                    joinErrorText.textContent = errorMsg;
                    // Don't clear localStorage here, let user retry or change inputs
                    return; 
                }

                const data = await response.json();
                currentPlayerId = data.playerId;
                currentPlayerName = data.gameState && data.gameState.playerName ? data.gameState.playerName : name; 
                currentRoomId = data.gameState && data.gameState.roomId ? data.gameState.roomId : roomId;


                localStorage.setItem('tambolaPlayerId', currentPlayerId);
                localStorage.setItem('tambolaPlayerName', currentPlayerName);
                localStorage.setItem('tambolaRoomId', currentRoomId);

                joinGameSection.classList.add('hidden');
                gameAreaDisplay.classList.remove('hidden');
                playerNameDisplay.textContent = currentPlayerName;
                roomDisplay.textContent = `Room: ${currentRoomId}`;
                roomDisplay.classList.remove('hidden');
                
                showToast(`Successfully joined Room: ${currentRoomId} as ${currentPlayerName}!`, 'success');

                if (data.gameState) {
                    updatePlayerFullState(data.gameState);
                } else {
                    await fetchPlayerFullState(); 
                }
                
                if (pollingIntervalId) clearInterval(pollingIntervalId);
                pollingIntervalId = setInterval(fetchPlayerFullState, 4000); 

            } catch (error) { 
                console.error("Error joining game (network or fetch issue):", error);
                joinErrorText.textContent = "An error occurred (e.g. network issue or backend not reachable). Please try again.";
            } finally {
                isJoining = false;
                joinGameBtn.disabled = false;
                joinGameBtn.classList.remove('loading');
            }
        }

        async function fetchPlayerFullState() {
            if (!currentPlayerId || !currentRoomId) return;
            try {
                const response = await fetch(`${API_BASE_URL}/api/player/state?playerId=${currentPlayerId}&roomId=${currentRoomId}`); 
                if (!response.ok) {
                    if (response.status === 401 || response.status === 403 || response.status === 404) { 
                        const errorData = await response.json().catch(() => ({message: "Session invalid or room/player not found. Please rejoin."}));
                        showToast(errorData.message, "error");
                        logoutAndResetUI(); // This will show the join screen again
                    } else {
                         const errorText = await response.text();
                        throw new Error(`HTTP error! status: ${response.status}, ${errorText}`);
                    }
                    return;
                }
                const state = await response.json();
                updatePlayerFullState(state);
            } catch (error) {
                console.error("Failed to fetch player game state:", error);
                showToast("Connection issue. Attempting to maintain current state.", "warning");
            }
        }
        
        function logoutAndResetUI() {
            if (pollingIntervalId) clearInterval(pollingIntervalId);
            pollingIntervalId = null;
            
            // Clear only playerId, keep name and room in inputs for potential re-attempt
            localStorage.removeItem('tambolaPlayerId'); 
            // currentPlayerId = null; // This will be handled by the next load or join attempt

            // Reset UI to join screen
            joinGameSection.classList.remove('hidden');
            gameAreaDisplay.classList.add('hidden');
            roomDisplay.classList.add('hidden'); 
            
            // Clear dynamic game content
            playerTickets = [];
            activeTicketIndex = 0;
            serverGameState = {};
            lastKnownDrawnNumbersCount = 0;
            ticketTabsContainer.innerHTML = '';
            ticketGridsContainer.innerHTML = `<p id="noTicketsText" class="text-center italic p-4">You have no tickets yet. Request one!</p>`;
            drawnNumbersListPlayerEl.innerHTML = `<span class="italic text-gray-500">Waiting for game to start...</span>`;
            currentNumberPlayerEl.textContent = '-';
            myClaimsListEl.innerHTML = `<p class="italic text-gray-500 p-2">You haven't made any claims yet.</p>`;
            statusTextPlayerEl.textContent = "Not Connected";
            gameOverMessagePlayerEl.classList.add('hidden');

            showToast("You have been disconnected. Please join again.", "info");
        }


        function updatePlayerFullState(state) {
            if (!state || !state.roomId) { 
                console.warn("Received invalid state from server:", state);
                // If state is truly invalid or indicates player is no longer valid for this room,
                // logoutAndResetUI() might be called by fetchPlayerFullState's error handling.
                // Avoid further processing here if state is bad.
                return;
            }
            serverGameState = state; 

            if (state.playerTickets && Array.isArray(state.playerTickets)) {
                const newClientTickets = [];
                let ticketsStructureChanged = playerTickets.length !== state.playerTickets.length;

                state.playerTickets.forEach(serverTicketData => {
                    if (!serverTicketData || !serverTicketData.id) return; 
                    const existingClientTicket = playerTickets.find(pt => pt.id === serverTicketData.id);
                    if (existingClientTicket) {
                        existingClientTicket.rows = serverTicketData.rows;
                        existingClientTicket.numbers = serverTicketData.numbers;
                        newClientTickets.push(existingClientTicket); 
                    } else {
                        newClientTickets.push({ ...serverTicketData, marked: new Set() }); 
                        ticketsStructureChanged = true;
                    }
                });
                playerTickets = newClientTickets;

                if (activeTicketIndex >= playerTickets.length) {
                    activeTicketIndex = Math.max(0, playerTickets.length - 1);
                    if (playerTickets.length > 0) ticketsStructureChanged = true; 
                }
                
                if (ticketsStructureChanged || (playerTickets.length > 0 && playerTickets[activeTicketIndex] && !document.getElementById(`ticket-grid-${playerTickets[activeTicketIndex].id}`))) {
                    renderTickets();
                } else if (playerTickets.length === 0 && ticketGridsContainer.innerHTML.includes('ticket-grid-wrapper')) {
                    renderTickets();
                }

            } else if (playerTickets.length > 0) { 
                playerTickets = []; 
                renderTickets(); 
            } else if (playerTickets.length === 0 && ticketGridsContainer.innerHTML.includes('ticket-grid-wrapper')) {
                 renderTickets(); 
            }

            updateTicketStatusText();

            currentNumberPlayerEl.textContent = state.currentNumber || '-';
            drawnCountPlayerEl.textContent = state.drawnNumbers?.length || 0;
            drawnNumbersListPlayerEl.innerHTML = (state.drawnNumbers && state.drawnNumbers.length > 0) ?
                state.drawnNumbers.map(num => `<span class="badge badge-lg badge-neutral">${num}</span>`).join(' ') :
                `<span class="italic text-gray-500">Waiting for game to start...</span>`;

            if (state.gameOver) {
                statusTextPlayerEl.textContent = "Game Over";
                gameOverMessagePlayerEl.classList.remove('hidden');
                addTicketBtn.disabled = true; 
                submitClaimBtn.disabled = true; 
                if (pollingIntervalId) clearInterval(pollingIntervalId); 
            } else if (state.gameStarted) {
                statusTextPlayerEl.textContent = "In Progress";
                gameOverMessagePlayerEl.classList.add('hidden');
                submitClaimBtn.disabled = false;
            } else {
                statusTextPlayerEl.textContent = "Not Started";
                gameOverMessagePlayerEl.classList.add('hidden');
                submitClaimBtn.disabled = true; 
            }

            if (isAutoMarkEnabled && state.drawnNumbers && state.drawnNumbers.length > lastKnownDrawnNumbersCount) {
                autoMarkDrawnNumbers(state.drawnNumbers);
            }
            lastKnownDrawnNumbersCount = state.drawnNumbers?.length || 0;

            highlightLatestDrawnOnTicket(state.currentNumber, state.drawnNumbers || []);
            populatePrizeOptions(state.winningRules);
            updateMyClaimsList(state.myClaims);
            
            if (state.myClaims) {
                state.myClaims.forEach(claim => {
                    if (!claim || !claim.claimId) return; 
                    const localClaimKey = `claim-${claim.claimId}-confetti`;
                    if (claim.status === 'accepted' && !localStorage.getItem(localClaimKey)) {
                        triggerConfetti();
                        showToast(`Your claim for ${capitalizeFirstLetter(claim.prizeType.replace(/([A-Z])/g, ' $1'))} was Accepted! Congratulations!`, "success");
                        localStorage.setItem(localClaimKey, 'shown'); 
                    }
                });
            }
        }

        function renderTickets() {
            ticketTabsContainer.innerHTML = '';
            ticketGridsContainer.innerHTML = '';

            if (playerTickets.length === 0) {
                ticketGridsContainer.innerHTML = `<p id="noTicketsText" class="text-center italic p-4">You have no tickets yet. Request one or wait for admin approval.</p>`;
                activeTicketIndex = 0; 
                return;
            }
            
            if (activeTicketIndex >= playerTickets.length) {
                 activeTicketIndex = Math.max(0, playerTickets.length - 1);
            }
            
            playerTickets.forEach((ticket, index) => {
                if (!ticket || !ticket.id) {
                    console.warn("Attempting to render invalid ticket data at index:", index, ticket);
                    return; 
                }
                const tab = document.createElement('a');
                tab.setAttribute('role', 'tab');
                tab.classList.add('tab', 'tab-ticket', 'text-xs', 'sm:text-sm');
                tab.textContent = `Ticket ${index + 1}`;
                tab.onclick = () => selectTicketTab(index);
                if (index === activeTicketIndex) {
                    tab.classList.add('active');
                }
                ticketTabsContainer.appendChild(tab);

                const gridDivWrapper = document.createElement('div');
                gridDivWrapper.id = `ticket-grid-${ticket.id}`;
                gridDivWrapper.classList.add('ticket-grid-wrapper');
                if (index !== activeTicketIndex) {
                    gridDivWrapper.classList.add('hidden');
                }
                
                const actualGrid = document.createElement('div');
                actualGrid.classList.add('ticket-grid');
                (ticket.rows || []).forEach(row => {
                    (row || []).forEach(number => {
                        const cell = document.createElement('div');
                        cell.classList.add('ticket-cell');
                        if (number !== null) {
                            cell.textContent = number;
                            cell.classList.add('number');
                            cell.dataset.number = number;
                            if (!(ticket.marked instanceof Set)) ticket.marked = new Set(ticket.marked || []);

                            if (ticket.marked && ticket.marked.has(number)) {
                                cell.classList.add('marked');
                            }
                            cell.onclick = () => manualMarkNumber(ticket, number, cell);
                        } else {
                            cell.classList.add('blank');
                        }
                        actualGrid.appendChild(cell);
                    });
                });
                gridDivWrapper.appendChild(actualGrid);
                ticketGridsContainer.appendChild(gridDivWrapper);
            });

            if (playerTickets.length > 0 && playerTickets[activeTicketIndex]) {
                 autoMarkDrawnNumbers(serverGameState.drawnNumbers || []); 
                 highlightLatestDrawnOnTicket(serverGameState.currentNumber, serverGameState.drawnNumbers || []);
            }
        }
        
        function selectTicketTab(index) {
            if (index < 0 || index >= playerTickets.length || !playerTickets[index] || !playerTickets[index].id) {
                console.warn("Invalid tab index or ticket data for selection:", index);
                return;
            }
            activeTicketIndex = index;
            Array.from(ticketTabsContainer.children).forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });
            Array.from(ticketGridsContainer.children).forEach((gridWrapper, i) => {
                gridWrapper.classList.toggle('hidden', i !== index);
            });
            if (playerTickets[activeTicketIndex]) { 
                autoMarkDrawnNumbers(serverGameState.drawnNumbers || []); 
                highlightLatestDrawnOnTicket(serverGameState.currentNumber, serverGameState.drawnNumbers || []);
            }
        }

        async function requestAnotherTicket() {
            if (isRequestingTicket) return;
            isRequestingTicket = true;
            addTicketBtn.disabled = true; 
            addTicketBtn.classList.add('loading');


            if (!currentPlayerId || !currentRoomId) {
                showToast("Player or Room ID not found. Please rejoin.", "error");
                isRequestingTicket = false;
                addTicketBtn.classList.remove('loading');
                addTicketBtn.disabled = false; 
                return;
            }
            if (playerTickets.length >= 5) {
                showToast("You already have the maximum of 5 tickets.", "warning");
                isRequestingTicket = false;
                addTicketBtn.classList.remove('loading');
                updateTicketStatusText(); 
                return;
            }


            ticketStatusText.textContent = "Requesting new ticket...";
            try {
                const response = await fetch(`${API_BASE_URL}/api/player/request-ticket`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ playerId: currentPlayerId, playerName: currentPlayerName, roomId: currentRoomId })
                });
                const data = await response.json();
                if (response.ok) {
                    showToast(data.message || "Ticket requested. Waiting for admin approval.", "info");
                    ticketStatusText.textContent = "Ticket requested. Waiting for admin approval.";
                } else {
                    showToast(data.message || "Failed to request ticket.", "error");
                    ticketStatusText.textContent = data.message || "Failed to request ticket.";
                }
            } catch (error) {
                console.error("Error requesting ticket:", error);
                showToast("Error requesting ticket. Please try again.", "error");
                ticketStatusText.textContent = "Error requesting ticket.";
            } finally {
                isRequestingTicket = false;
                addTicketBtn.classList.remove('loading');
                updateTicketStatusText(); 
            }
        }
        
        function updateTicketStatusText() {
            const numTickets = playerTickets.length;
            if (numTickets >= 5) {
                ticketStatusText.textContent = "You have the maximum (5) tickets.";
                addTicketBtn.disabled = true;
            } else {
                ticketStatusText.textContent = `You have ${numTickets} ticket(s). You can request ${5-numTickets} more.`;
                addTicketBtn.disabled = (serverGameState && serverGameState.gameOver) || isRequestingTicket; 
            }
        }

        function toggleAutoMark(enabled) {
            isAutoMarkEnabled = enabled;
            localStorage.setItem('tambolaAutoMark', enabled); 
            if (isAutoMarkEnabled && playerTickets.length > 0 && playerTickets[activeTicketIndex]) {
                autoMarkDrawnNumbers(serverGameState.drawnNumbers || []);
            }
        }


        function autoMarkDrawnNumbers(drawnNumbersArray) {
            if (playerTickets.length === 0 || !playerTickets[activeTicketIndex] || !playerTickets[activeTicketIndex].id) return;

            const currentVisibleTicket = playerTickets[activeTicketIndex];
            if (!(currentVisibleTicket.marked instanceof Set)) {
                currentVisibleTicket.marked = new Set(currentVisibleTicket.marked || []);
            }

            const drawnSet = new Set(drawnNumbersArray);
            const gridWrapper = document.getElementById(`ticket-grid-${currentVisibleTicket.id}`);
            if (!gridWrapper) { return; }

            (currentVisibleTicket.numbers || []).forEach(numOnTicket => {
                const cell = gridWrapper.querySelector(`.ticket-cell[data-number="${numOnTicket}"]`);
                if (cell) {
                    if (drawnSet.has(numOnTicket)) {
                        if (!currentVisibleTicket.marked.has(numOnTicket)) {
                             if (isAutoMarkEnabled) { 
                                cell.classList.add('marked');
                                currentVisibleTicket.marked.add(numOnTicket);
                                triggerConfetti(cell); 
                             }
                        } else { 
                             cell.classList.add('marked'); 
                        }
                    }
                }
            });
        }
        
        function manualMarkNumber(ticket, number, cellElement) {
            if (!ticket || !ticket.id) return; 
            if (!(ticket.marked instanceof Set)) {
                ticket.marked = new Set(ticket.marked || []);
            }

            if (!serverGameState.drawnNumbers || !serverGameState.drawnNumbers.includes(number)) {
                showToast(`Number ${number} has not been drawn yet!`, "warning");
                return;
            }

            if (ticket.marked.has(number)) {
                ticket.marked.delete(number);
                cellElement.classList.remove('marked');
            } else {
                ticket.marked.add(number);
                cellElement.classList.add('marked');
                triggerConfetti(cellElement); 
            }
        }

        function highlightLatestDrawnOnTicket(latestNumber, drawnNumbersArray) {
            document.querySelectorAll('.ticket-cell.drawn-highlight').forEach(c => c.classList.remove('drawn-highlight'));
            if (!latestNumber || playerTickets.length === 0 || !playerTickets[activeTicketIndex] || !playerTickets[activeTicketIndex].id) return;
            
            const currentVisibleTicket = playerTickets[activeTicketIndex];
            const gridWrapper = document.getElementById(`ticket-grid-${currentVisibleTicket.id}`);
            if (!gridWrapper) { return; }

            const cellToHighlight = gridWrapper.querySelector(`.ticket-cell[data-number="${latestNumber}"]`);
            if (cellToHighlight && drawnNumbersArray && drawnNumbersArray.includes(latestNumber)) {
                cellToHighlight.classList.add('drawn-highlight');
                setTimeout(() => cellToHighlight.classList.remove('drawn-highlight'), 3000); 
            }
        }
        
        function populatePrizeOptions(winningRules) {
            prizeTypeSelect.innerHTML = ''; 
            if (!winningRules || Object.keys(winningRules).length === 0) {
                prizeTypeSelect.innerHTML = '<option disabled selected>No prizes configured</option>';
                submitClaimBtn.disabled = true;
                return;
            }
            let hasActivePrizes = false;
            for (const prizeKey in winningRules) {
                if (winningRules[prizeKey].enabled) {
                    hasActivePrizes = true;
                    const option = document.createElement('option');
                    option.value = prizeKey;
                    option.textContent = capitalizeFirstLetter(prizeKey.replace(/([A-Z])/g, ' $1').trim()) + ` (Max ${winningRules[prizeKey].maxWinners} winner/s)`;
                    prizeTypeSelect.appendChild(option);
                }
            }
            if(!hasActivePrizes){
                 prizeTypeSelect.innerHTML = '<option disabled selected>No active prizes</option>';
                 submitClaimBtn.disabled = true;
            } else {
                submitClaimBtn.disabled = (serverGameState && serverGameState.gameOver) || isSubmittingClaim;
            }
        }
        
        async function submitClaim() {
            if (isSubmittingClaim) return;
            isSubmittingClaim = true;
            submitClaimBtn.disabled = true; 
            submitClaimBtn.classList.add('loading');

            if (playerTickets.length === 0 || !playerTickets[activeTicketIndex] || !playerTickets[activeTicketIndex].id) {
                showToast("No active ticket selected to make a claim.", "warning");
                isSubmittingClaim = false;
                submitClaimBtn.classList.remove('loading');
                submitClaimBtn.disabled = (serverGameState && serverGameState.gameOver);
                return;
            }
            const activeTicket = playerTickets[activeTicketIndex];
            const prizeType = prizeTypeSelect.value;

            if (!prizeType) {
                showToast("Please select a prize type to claim.", "warning");
                isSubmittingClaim = false;
                submitClaimBtn.classList.remove('loading');
                submitClaimBtn.disabled = (serverGameState && serverGameState.gameOver);
                return;
            }

            if (!(activeTicket.marked instanceof Set)) {
                 activeTicket.marked = new Set(activeTicket.marked || []);
            }
            const numbersForClaim = Array.from(activeTicket.marked);

            claimStatusMessageEl.textContent = 'Submitting claim...';
            claimStatusMessageEl.className = 'mt-4 text-center font-medium text-info';

            try {
                const response = await fetch(`${API_BASE_URL}/api/player/claim-prize`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        playerId: currentPlayerId,
                        ticketId: activeTicket.id,
                        prizeType: prizeType,
                        playerNumbers: numbersForClaim,
                        roomId: currentRoomId 
                    })
                });
                const result = await response.json();
                if (response.ok) {
                    claimStatusMessageEl.textContent = `Success: ${result.message}`;
                    claimStatusMessageEl.className = 'mt-4 text-center font-medium text-success';
                    showToast(result.message || "Claim submitted!", "success");
                } else {
                    claimStatusMessageEl.textContent = `Failed: ${result.message}`;
                    claimStatusMessageEl.className = 'mt-4 text-center font-medium text-error';
                    showToast(result.message || "Claim failed.", "error");
                }
            } catch (error) {
                console.error("Failed to claim prize:", error);
                claimStatusMessageEl.textContent = 'Error submitting claim. Check console.';
                showToast("Error submitting claim.", "error");
            } finally {
                isSubmittingClaim = false;
                submitClaimBtn.classList.remove('loading');
                submitClaimBtn.disabled = (serverGameState && serverGameState.gameOver);
                fetchPlayerFullState(); 
            }
        }

        function updateMyClaimsList(claimsData) {
            if (!claimsData || claimsData.length === 0) {
                myClaimsListEl.innerHTML = `<p class="italic text-gray-500 p-2">You haven't made any claims yet.</p>`;
                return;
            }
            myClaimsListEl.innerHTML = claimsData.map(claim => {
                if (!claim || !claim.prizeType || !claim.ticketId || !claim.status) return ''; 
                return `
                <div class="list-item text-sm p-2 border-b flex justify-between items-center">
                    <span><strong>${capitalizeFirstLetter(claim.prizeType.replace(/([A-Z])/g, ' $1'))}</strong> (Ticket: ...${claim.ticketId.slice(-6)})</span>
                    <span class="badge ${claim.status === 'accepted' ? 'badge-success' : claim.status === 'rejected' ? 'badge-error' : 'badge-warning'} badge-sm">
                        ${capitalizeFirstLetter(claim.status)}
                    </span>
                </div>`;
            }).join('');
        }

        function triggerConfetti(element) {
            const rect = element ? element.getBoundingClientRect() : null;
            const origin = element && rect ? {
                x: (rect.left + rect.right) / 2 / window.innerWidth,
                y: (rect.top + rect.bottom) / 2 / window.innerHeight
            } : { x: 0.5, y: 0.7 }; 

            confetti({
                particleCount: 80,
                spread: 60,
                origin: origin,
                zIndex: 10000 
            });
        }
        
        function capitalizeFirstLetter(string) {
            if (!string) return '';
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        function closeDrawer() {
            const drawerCheckbox = document.getElementById('player-drawer');
            if (drawerCheckbox) drawerCheckbox.checked = false;
        }
        function closeDrawerAndScroll(sectionId) {
            closeDrawer();
            const section = document.querySelector(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

    </script>
</body>
</html>
