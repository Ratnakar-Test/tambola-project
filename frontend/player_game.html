<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tambola Game - Play</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@latest/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            /* Add padding to prevent content from being hidden by top and bottom bars */
            padding-top: 70px; /* Approx height of top nav */
            padding-bottom: 100px; /* Approx height of bottom nav */
        }
        .flex-grow {
            flex-grow: 1;
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
        .drawer-side > *:not(label) { overflow-y: auto; }

        /* Ticket Styling */
        .ticket-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px; /* Smaller gap for tighter ticket look */
            border: 1px solid oklch(var(--bc)); /* Border color from DaisyUI */
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.25rem; /* p-1 */
            background-color: oklch(var(--b2)); /* Base-200 for ticket background */
            margin-bottom: 1rem; /* Space between tickets */
            max-width: 500px; /* Max width for a ticket */
            margin-left: auto;
            margin-right: auto;
        }
        .ticket-cell {
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1 / 1;
            min-height: 35px; /* Ensure cells are not too small */
            border: 1px solid oklch(var(--b3)); /* Base-300 for cell borders */
            border-radius: 0.25rem; /* rounded-sm */
            font-weight: bold;
            cursor: pointer; /* For manual marking */
            transition: background-color 0.3s, color 0.3s, transform 0.2s;
            background-color: oklch(var(--b1)); /* Base-100 for empty/number cells */
        }
        .ticket-cell.empty {
            background-color: oklch(var(--b2)); /* Slightly different for empty cells */
            cursor: default;
        }
        .ticket-cell.marked {
            background-color: oklch(var(--p)); /* Primary color for marked */
            color: oklch(var(--pc)); /* Primary content color */
            transform: scale(1.05);
            box-shadow: 0 0 8px oklch(var(--p));
        }
        .ticket-cell.marked-boogie { /* For incorrect manual marking */
            background-color: oklch(var(--er)); /* Error color */
            color: oklch(var(--ec));
            animation: shake 0.5s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
        }

        /* Called Numbers Bar */
        .called-numbers-bar {
            display: flex;
            overflow-x: auto; /* Horizontal scroll */
            padding: 0.5rem;
            gap: 0.5rem;
            background-color: oklch(var(--b2));
            border-radius: 0.5rem;
            margin-bottom: 1rem;
        }
        .called-number-badge {
            flex-shrink: 0; /* Prevent badges from shrinking */
        }
        /* Floating Nav Bars */
        .top-nav-player {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
        }
        .bottom-nav-player-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: oklch(var(--b1));
            padding: 0.75rem;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
            z-index: 45;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            justify-content: space-around; /* Evenly space controls */
        }
         /* Game message styling */
        .game-message-popup {
            position: fixed;
            top: 80px; /* Below navbar */
            right: 1rem;
            padding: 0.75rem 1rem;
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 0.875rem; /* text-sm */
            z-index: 1000; /* High z-index */
            max-width: 300px;
            word-wrap: break-word;
        }
    </style>
</head>
<body x-data="playerGame()">
    <div class="drawer lg:drawer-open">
        <input id="player-drawer" type="checkbox" class="drawer-toggle" x-model="isDrawerOpen" />
        <div class="drawer-content flex flex-col bg-base-200">
            <nav class="navbar bg-base-100 shadow-lg top-nav-player">
                <div class="flex-none">
                    <label for="player-drawer" class="btn btn-square btn-ghost lg:hidden" aria-label="Open menu">
                        <i class="fas fa-bars text-xl"></i>
                    </label>
                </div>
                <div class="flex-1">
                    <div class="avatar placeholder mr-2 ml-2">
                        <div class="bg-neutral-focus text-neutral-content rounded-full w-10 h-10">
                            <span class="text-xl" x-text="playerName ? playerName.charAt(0).toUpperCase() : 'P'"></span>
                        </div>
                    </div>
                    <a class="btn btn-ghost normal-case text-lg sm:text-xl">Welcome, <span x-text="playerName || 'Player'"></span>!</a>
                </div>
                <div class="flex-none">
                    <div class="mr-2 indicator">
                         <span class="indicator-item indicator-top indicator-start badge badge-secondary" x-text="coinsWon > 0 ? '+' + coinsWon.toFixed(2) : coinsWon.toFixed(2)"></span>
                        <i class="fas fa-coins text-yellow-500 text-2xl"></i>
                    </div>
                    <div class="dropdown dropdown-end">
                        <label tabindex="0" class="btn btn-ghost btn-circle" aria-label="Theme selector">
                            <i class="fas fa-palette"></i>
                        </label>
                        <ul tabindex="0" class="menu menu-sm dropdown-content mt-3 z-[1] p-2 shadow bg-base-100 rounded-box w-52">
                            <template x-for="theme in themes" :key="theme">
                                <li><a @click="setTheme(theme, $event)" x-text="theme.charAt(0).toUpperCase() + theme.slice(1)"></a></li>
                            </template>
                        </ul>
                    </div>
                    <button @click="logout" class="btn btn-ghost btn-circle" aria-label="Logout">
                        <i class="fas fa-sign-out-alt text-xl"></i>
                    </button>
                </div>
            </nav>

            <main class="flex-grow p-4 overflow-y-auto">
                <div x-show="currentView === 'home'" x-transition>
                    <div class="mb-6">
                        <h3 class="text-xl font-semibold mb-1 text-center">Room: <span x-text="roomId" class="font-mono"></span></h3>
                        <div class="text-center mb-1">Admin: <span x-text="adminName || 'N/A'"></span></div>
                        <div class="text-center mb-3">Status: <span class="badge badge-lg"
                            :class="{
                                'badge-neutral': gameStatus === 'idle' || gameStatus === 'connecting' || gameStatus === 'disconnected',
                                'badge-success': gameStatus === 'running',
                                'badge-warning': gameStatus === 'paused',
                                'badge-error': gameStatus === 'stopped' || gameStatus === 'error'
                            }"
                            x-text="gameStatus"></span>
                        </div>

                        <div class="flex items-center justify-center mb-3">
                            <span class="mr-2">Latest:</span>
                            <span class="badge badge-accent badge-lg p-4 text-2xl" x-text="latestCalledNumber || '---'"></span>
                        </div>
                        <div class="called-numbers-bar">
                            <template x-if="calledNumbersHistory.length === 0">
                                <span class="italic text-base-content/70">No numbers called yet.</span>
                            </template>
                            <template x-for="num in calledNumbersHistory.slice().reverse()" :key="num"> <span class="badge badge-neutral called-number-badge" x-text="num"></span>
                            </template>
                        </div>
                    </div>

                    <div class="space-y-6">
                        <template x-if="tickets.length === 0 && gameStatus !== 'idle' && gameStatus !== 'stopped' && gameStatus !== 'connecting' && gameStatus !== 'disconnected'">
                            <div class="text-center p-6 bg-base-100 rounded-lg shadow">
                                <p class="text-lg">You don't have any tickets yet!</p>
                                <button @click="requestNewTicket" class="btn btn-primary mt-4" :disabled="waitingForTicketApproval || tickets.length >= 5 || gameStatus !== 'running'">
                                    Request a Ticket <span x-show="waitingForTicketApproval">(Pending...)</span>
                                </button>
                            </div>
                        </template>
                         <template x-if="tickets.length === 0 && (gameStatus === 'idle' || gameStatus === 'stopped' || gameStatus === 'connecting' || gameStatus === 'disconnected')">
                             <div class="text-center p-6 bg-base-100 rounded-lg shadow">
                                <p class="text-lg" x-text="gameStatusMessage"></p>
                             </div>
                         </template>
                        <template x-for="(ticket, ticketIndex) in tickets" :key="ticket.id">
                            <div class="card bg-base-100 shadow-xl">
                                <div class="card-body p-2 sm:p-4">
                                    <h4 class="card-title text-sm sm:text-base justify-center mb-2">Ticket <span x-text="ticketIndex + 1"></span> <span class="text-xs">(ID: <span x-text="ticket.id.substring(0,6)"></span>)</span></h4>
                                    <div class="ticket-grid">
                                        <template x-for="(row, rowIndex) in ticket.numbers" :key="rowIndex">
                                            <template x-for="(cell, cellIndex) in row" :key="cellIndex">
                                                <div class="ticket-cell"
                                                     :class="{
                                                         'empty': cell === null,
                                                         'marked': ticket.marked.includes(cell) && cell !== null,
                                                         'marked-boogie': tempBoogieCells.includes(ticket.id + '-' + cell)
                                                     }"
                                                     @click="manualMarkNumber(ticket.id, cell)"
                                                     x-text="cell !== null ? cell : ''">
                                                </div>
                                            </template>
                                        </template>
                                    </div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>

                <div x-show="currentView === 'players'" x-transition>
                     <h2 class="text-2xl font-bold mb-4">Other Players in Room (<span x-text="roomId"></span>)</h2>
                    <div class="overflow-x-auto bg-base-100 p-4 rounded-lg shadow">
                        <table class="table table-zebra w-full">
                            <thead><tr><th>#</th><th>Player Name</th><th>Tickets</th></tr></thead>
                            <tbody>
                                <template x-if="otherPlayers.length === 0 && !adminNameInPlayerList"><tr><td colspan="3" class="text-center">No other players visible yet.</td></tr></template>
                                <tr x-show="adminNameInPlayerList"><td>ðŸ‘‘</td><td x-text="adminNameInPlayerList.split(' (')[0]"></td><td>Admin <span x-show="adminNameInPlayerList.includes('(Disconnected)')" class="text-xs text-error">(Disconnected)</span></td></tr>
                                <template x-for="(player, index) in otherPlayers" :key="player.id">
                                    <tr>
                                        <td x-text="index + 1"></td>
                                        <td x-text="player.name"></td>
                                        <td x-text="player.ticketCount" class="text-center"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div x-show="currentView === 'rules'" x-transition>
                    <h2 class="text-2xl font-bold mb-4">Game Rules & Prizes</h2>
                     <div class="space-y-3">
                        <template x-if="gameRules.length === 0">
                            <p class="text-center italic bg-base-100 p-4 rounded-lg shadow">Rules not loaded yet or no rules defined by admin.</p>
                        </template>
                        <template x-for="rule in gameRules" :key="rule.id">
                            <div class="card bg-base-100 shadow-md" :class="{'opacity-70': !rule.isActive}"> <div class="card-body p-4">
                                    <h3 class="card-title text-lg" x-text="rule.name"></h3>
                                    <p class="text-xs text-base-content/70" x-text="rule.description"></p>
                                    <div x-show="rule.isActive" class="text-sm mt-1">
                                        <span>Value: <strong x-text="rule.coinsPerPrize ? rule.coinsPerPrize.toFixed(2) : 'N/A'"></strong></span> |
                                        <span>Max Winners: <strong x-text="rule.maxPrizes"></strong></span>
                                    </div>
                                     <div x-show="!rule.isActive" class="text-sm mt-1 italic"> (This rule is not active for the current game) </div>
                                </div>
                            </div>
                        </template>
                    </div>
                </div>
                <div x-show="currentView === 'myClaims'" x-transition>
                    <h2 class="text-2xl font-bold mb-4">My Prize Claims</h2>
                    <div class="overflow-x-auto bg-base-100 p-4 rounded-lg shadow">
                        <table class="table table-zebra w-full">
                            <thead><tr><th>Prize Claimed</th><th>Status</th><th>Reason (if rejected)</th></tr></thead>
                            <tbody>
                                <template x-if="myClaims.length === 0"><tr><td colspan="3" class="text-center">You haven't made any claims yet.</td></tr></template>
                                <template x-for="claim in myClaims" :key="claim.claimId">
                                    <tr>
                                        <td x-text="claim.prizeName"></td>
                                        <td>
                                            <span class="badge"
                                                  :class="{'badge-success': claim.status === 'approved', 'badge-error': claim.status === 'rejected', 'badge-warning': claim.status === 'pending_admin_approval' || claim.status === 'pending'}"
                                                  x-text="claim.status.replace(/_/g, ' ')"> </span>
                                        </td>
                                        <td x-text="claim.reason || '---'"></td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div x-show="currentView === 'myPrizes'" x-transition>
                    <h2 class="text-2xl font-bold mb-4">My Won Prizes</h2>
                    <div class="overflow-x-auto bg-base-100 p-4 rounded-lg shadow">
                        <table class="table table-zebra w-full">
                            <thead><tr><th>Prize Won</th><th>Value Received</th></tr></thead>
                            <tbody>
                                <template x-if="myPrizes.length === 0"><tr><td colspan="2" class="text-center">You haven't won any prizes yet.</td></tr></template>
                                <template x-for="prize in myPrizes" :key="prize.id"> <tr><td x-text="prize.prizeName"></td><td x-text="prize.coins.toFixed(2)"></td></tr>
                                </template>
                            </tbody>
                        </table>
                    </div>
                </div>

                <div x-show="gameMessage" x-transition:enter="transition ease-out duration-300" x-transition:enter-start="opacity-0 transform translate-y-2" x-transition:enter-end="opacity-100 transform translate-y-0" x-transition:leave="transition ease-in duration-300" x-transition:leave-start="opacity-100 transform translate-y-0" x-transition:leave-end="opacity-0 transform translate-y-2"
                     class="game-message-popup"
                     :class="{ 'bg-error text-error-content': gameMessageType === 'error',
                               'bg-warning text-warning-content': gameMessageType === 'warning',
                               'bg-info text-info-content': gameMessageType === 'info',
                               'bg-success text-success-content': gameMessageType === 'success' }"
                     x-text="gameMessage">
                </div>
            </main>
        </div>
        <div class="drawer-side z-[55]"> <label for="player-drawer" aria-label="close sidebar" class="drawer-overlay"></label>
            <ul class="menu p-4 w-80 min-h-full bg-base-100 text-base-content">
                <li class="mb-2 text-center">
                    <span class="text-lg font-bold">Player Menu</span>
                    <button @click="isDrawerOpen = false" class="btn btn-ghost btn-sm btn-circle absolute top-2 right-2 lg:hidden">âœ•</button>
                </li>
                <li><a @click="changeView('home')" :class="{ 'active': currentView === 'home' }"><i class="fas fa-ticket-alt mr-2"></i>My Tickets</a></li>
                <li><a @click="changeView('players')" :class="{ 'active': currentView === 'players' }"><i class="fas fa-users mr-2"></i>Players in Room</a></li>
                <li><a @click="changeView('rules')" :class="{ 'active': currentView === 'rules' }"><i class="fas fa-gavel mr-2"></i>Game Rules</a></li>
                <li><a @click="changeView('myClaims')" :class="{ 'active': currentView === 'myClaims' }"><i class="fas fa-hand-paper mr-2"></i>My Claims</a></li>
                <li><a @click="changeView('myPrizes')" :class="{ 'active': currentView === 'myPrizes' }"><i class="fas fa-trophy mr-2"></i>My Prizes</a></li>
            </ul>
        </div>
    </div>

    <div class="bottom-nav-player-controls">
        <button @click="requestNewTicket" class="btn btn-secondary btn-sm" :disabled="tickets.length >= 5 || waitingForTicketApproval || gameStatus !== 'running'">
            <i class="fas fa-plus-circle mr-1"></i> Add Ticket <span x-show="waitingForTicketApproval">(Pending...)</span>
        </button>

        <button class="btn btn-accent btn-sm" @click="openClaimModal" :disabled="!canClaimPrize || gameStatus !== 'running' || tickets.length === 0">
            <i class="fas fa-award mr-1"></i> Claim Prize
        </button>

        <div class="form-control">
            <label class="label cursor-pointer">
                <span class="label-text mr-2">Auto-Mark:</span>
                <input type="checkbox" class="toggle toggle-primary" x-model="autoMarkNumbers" @change="toggleAutoMarkBehavior()" />
            </label>
        </div>
    </div>

    <dialog id="claim_prize_modal" class="modal" x-ref="claimModal">
        <div class="modal-box">
            <h3 class="font-bold text-lg">Claim a Prize!</h3>
            <p class="py-2">Select the prize you want to claim for one of your tickets:</p>
            <div class="form-control mb-3">
                <label class="label"><span class="label-text">Claim on which ticket?</span></label>
                <select x-model="selectedTicketIdForClaim" class="select select-bordered w-full">
                    <template x-for="(ticket, index) in tickets" :key="ticket.id">
                        <option :value="ticket.id" x-text="'Ticket ' + (index + 1)"></option>
                    </template>
                </select>
            </div>
            <div class="space-y-2 max-h-60 overflow-y-auto">
                <template x-for="prize in availablePrizesToClaim" :key="prize.id">
                     <button
                        class="btn btn-outline btn-primary w-full justify-start"
                        @click="submitPrizeClaim(prize.id)"
                        :disabled="!selectedTicketIdForClaim || prizeAlreadyClaimedOrWon(prize.id)">
                        <span x-text="prize.name"></span>
                        (<span x-text="prize.coinsPerPrize ? prize.coinsPerPrize.toFixed(2) : 'N/A'"></span> value)
                        <span x-show="prizeAlreadyClaimedOrWon(prize.id)" class="text-xs text-neutral-content/50 ml-auto">(Claimed/Won)</span>
                    </button>
                </template>
                <template x-if="availablePrizesToClaim.length === 0 && gameRules.length > 0">
                    <p class="italic text-center">All available prizes may have been claimed or won, or do not match your tickets.</p>
                </template>
                 <template x-if="gameRules.length === 0">
                    <p class="italic text-center">No prize rules defined by admin for this game.</p>
                </template>
            </div>
            <div class="modal-action"> <form method="dialog"><button class="btn">Close</button></form> </div>
        </div>
         <form method="dialog" class="modal-backdrop"><button>close</button></form>
    </dialog>


    <script>
    function playerGame() {
        return {
            // Core Player Info
            playerName: '',
            playerId: null,
            roomId: '',
            adminName: '', // Name of the admin for display
            adminNameInPlayerList: null, // For player list display with status

            // WebSocket and UI State
            socket: null,
            coinsWon: 0,
            isDrawerOpen: false,
            currentView: 'home',
            themes: [ /* Theme list from previous correct version */
                "light", "dark", "cupcake", "bumblebee", "emerald", "corporate", "synthwave", "retro", "cyberpunk", "valentine", "halloween", "garden", "forest", "aqua", "lofi", "pastel", "fantasy", "wireframe", "black", "luxury", "dracula", "cmyk", "autumn", "business", "acid", "lemonade", "night", "coffee", "winter"
            ],

            // Game Data
            tickets: [],
            calledNumbersHistory: [],
            latestCalledNumber: null,
            autoMarkNumbers: true,
            tempBoogieCells: [], // For visual feedback on incorrect manual marks

            // Room & Game Info from Server
            otherPlayers: [],
            gameRules: [],
            myClaims: [],
            myPrizes: [],

            // UI Interaction State
            waitingForTicketApproval: false,
            canClaimPrize: false,
            availablePrizesToClaim: [],
            selectedTicketIdForClaim: null,

            // Game Status & Messaging
            gameStatus: 'connecting', // 'connecting', 'idle', 'running', 'paused', 'stopped', 'disconnected', 'error'
            gameMessage: '',
            gameMessageType: 'info',
            gameMessageTimeout: null,

            // Computed property for game status message
            get gameStatusMessage() {
                switch(this.gameStatus) {
                    case 'connecting': return 'Connecting to server...';
                    case 'idle': return 'Waiting for the game to start...';
                    case 'stopped': return 'The game has ended. Thank you for playing!';
                    case 'disconnected': return 'Disconnected from server. Please refresh.';
                    case 'error': return 'A connection error occurred. Please refresh.';
                    default: return `Game status: ${this.gameStatus}`;
                }
            },


            // Initialization
            init() {
                const savedTheme = localStorage.getItem('theme') || 'light';
                this.setTheme(savedTheme, null, false); // THEME SELECTOR LOGIC

                const urlParams = new URLSearchParams(window.location.search);
                this.playerName = localStorage.getItem('playerName') || urlParams.get('playerName') || null;
                this.roomId = localStorage.getItem('roomId') || urlParams.get('roomId') || null;

                if (!this.playerName || !this.roomId) {
                    this.showGameMessage("Player Name or Room ID missing. Please join a room first.", "error", null);
                    this.gameStatus = 'error';
                    // Optional: Redirect to join page after a delay
                    // setTimeout(() => { window.location.href = 'player_join.html'; }, 3000);
                    return;
                }
                this.connectWebSocket();

                // Watch for changes in tickets to auto-select first ticket for claim if none selected
                this.$watch('tickets', (newTickets) => {
                    if (newTickets.length > 0 && !this.selectedTicketIdForClaim) {
                        this.selectedTicketIdForClaim = newTickets[0].id;
                    } else if (newTickets.length === 0) {
                        this.selectedTicketIdForClaim = null;
                    }
                });
            },

            // WebSocket Handling
            connectWebSocket() {
                this.gameStatus = 'connecting';
                // IMPORTANT: Replace with your actual backend URL for production
                const socketURL = (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')
                    ? `ws://${window.location.hostname}:3000`
                    : `wss://tambola-backend.onrender.com`;

                this.socket = new WebSocket(socketURL);

                this.socket.onopen = () => {
                    console.log('Player WebSocket: Connection established.');
                    // Message shown on PLAYER_JOIN_SUCCESS
                    this.socket.send(JSON.stringify({
                        type: 'PLAYER_JOIN_ROOM',
                        payload: { playerName: this.playerName, roomId: this.roomId }
                    }));
                };

                this.socket.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleWebSocketMessage(message);
                };

                this.socket.onclose = (event) => {
                    console.warn('Player WebSocket: Connection closed.', event.code, event.reason);
                    this.gameStatus = 'disconnected';
                    this.showGameMessage('Disconnected from server. Please refresh to rejoin.', 'error', null);
                };

                this.socket.onerror = (error) => {
                    console.error('Player WebSocket: Error:', error);
                    this.gameStatus = 'error';
                    this.showGameMessage('WebSocket connection error. Server might be unavailable or busy.', 'error', null);
                };
            },

            handleWebSocketMessage(data) {
                console.log("Player received WS message:", data); // For debugging
                const { type, payload } = data;
                switch(type) {
                    case 'PLAYER_JOIN_SUCCESS':
                        this.playerId = payload.playerId;
                        this.playerName = payload.playerName;
                        this.tickets = payload.tickets || [];
                        this.gameStatus = payload.gameStatus || 'idle';
                        this.calledNumbersHistory = payload.calledNumbers || [];
                        this.gameRules = payload.rules || [];
                        this.adminName = payload.adminName || 'N/A';
                        this.adminNameInPlayerList = payload.adminName; // For player list
                        this.otherPlayers = payload.playersInRoom?.filter(p => p.id !== this.playerId) || [];

                        this.showGameMessage(`Joined Room ${this.roomId}. Admin: ${this.adminName}.`, 'success');
                        if (this.calledNumbersHistory.length > 0) {
                            this.latestCalledNumber = this.calledNumbersHistory[this.calledNumbersHistory.length - 1];
                            if(this.autoMarkNumbers) { this.calledNumbersHistory.forEach(num => this.markNumberOnTickets(num)); }
                        }
                        this.updateAvailablePrizes();
                        this.updateCanClaimPrizeStatus();
                        if (this.tickets.length > 0) this.selectedTicketIdForClaim = this.tickets[0].id; // Default selected ticket
                        break;
                    case 'NUMBER_CALLED':
                        this.latestCalledNumber = payload.number;
                        this.calledNumbersHistory = payload.calledNumbersHistory;
                        if (this.autoMarkNumbers) { this.markNumberOnTickets(payload.number); }
                        this.updateCanClaimPrizeStatus();
                        break;
                    case 'RULES_UPDATED':
                        this.gameRules = payload.rules || [];
                        this.updateAvailablePrizes(); // Recalculate claimable prizes
                        this.showGameMessage("Game rules have been updated.", "info");
                        break;
                    case 'TICKET_APPROVED':
                        this.tickets.push(payload.ticket);
                        this.waitingForTicketApproval = false;
                        this.showGameMessage("New ticket added by admin!", "success", 3000);
                        this.triggerConfetti();
                        if (this.tickets.length === 1) this.selectedTicketIdForClaim = this.tickets[0].id; // Auto-select if it's the first
                        break;
                    case 'TICKET_REJECTED':
                        this.waitingForTicketApproval = false;
                        this.showGameMessage(`Ticket request rejected. ${payload.reason || ''}`, "warning", 4000);
                        break;
                    case 'CLAIM_STATUS_UPDATE':
                        const claimIndex = this.myClaims.findIndex(c => c.claimId === payload.claimId);
                        if (claimIndex !== -1) {
                            this.myClaims[claimIndex].status = payload.status;
                            this.myClaims[claimIndex].reason = payload.reason || '';
                            if (payload.status === 'approved') {
                                const approvedPrizeName = this.myClaims[claimIndex].prizeName;
                                // Check if this prize instance is already in myPrizes to avoid duplicates
                                if (!this.myPrizes.some(p => p.id === 'prize_' + payload.claimId)) {
                                    this.myPrizes.push({ id: 'prize_' + payload.claimId, prizeName: approvedPrizeName, coins: payload.coinsAwarded });
                                    this.coinsWon = parseFloat((this.coinsWon + payload.coinsAwarded).toFixed(2));
                                }
                                this.showGameMessage(`Claim for ${approvedPrizeName} APPROVED! +${payload.coinsAwarded.toFixed(2)}`, "success", 5000);
                                this.triggerConfetti();
                            } else {
                                this.showGameMessage(`Claim for ${this.myClaims[claimIndex].prizeName} REJECTED. ${payload.reason || ''}`, "error", 5000);
                            }
                        } else if (payload.status === 'approved') { // If claim was somehow not in local list but server approved
                             if (!this.myPrizes.some(p => p.id === 'prize_' + payload.claimId)) {
                                this.myPrizes.push({ id: 'prize_' + payload.claimId, prizeName: payload.prizeName, coins: payload.coinsAwarded });
                                this.coinsWon = parseFloat((this.coinsWon + payload.coinsAwarded).toFixed(2));
                             }
                             this.showGameMessage(`${payload.prizeName} prize APPROVED! +${payload.coinsAwarded.toFixed(2)}`, "success", 5000);
                        }
                        this.updateAvailablePrizes(); // Re-check available prizes
                        break;
                    case 'PLAYER_LIST_UPDATE':
                        this.otherPlayers = payload.players.filter(p => p.id !== this.playerId);
                        break;
                    case 'ADMIN_STATUS_UPDATE': // Admin connected/disconnected
                        this.adminName = payload.adminName; // Update admin name display
                        this.adminNameInPlayerList = payload.isConnected ? payload.adminName : `${payload.adminName} (Disconnected)`;
                        this.showGameMessage(payload.isConnected ? `Admin ${payload.adminName} is connected.` : `Admin ${payload.adminName} has disconnected. Game might be paused.`, "info");
                        break;
                    case 'GAME_STARTED':
                        this.gameStatus = 'running';
                        this.calledNumbersHistory = []; this.latestCalledNumber = null;
                        this.tickets.forEach(t => t.marked = []); // Clear marks on existing tickets
                        this.myClaims = []; this.myPrizes = []; this.coinsWon = 0; // Reset claims and winnings
                        this.gameRules = payload.rules || [];
                        this.adminName = payload.adminName || this.adminName;
                        this.adminNameInPlayerList = this.adminName;
                        this.showGameMessage(`Game has started by ${this.adminName}! Good luck!`, "success", 5000);
                        this.updateAvailablePrizes();
                        this.updateCanClaimPrizeStatus();
                        break;
                    case 'GAME_PAUSED': case 'GAME_RESUMED':
                        this.gameStatus = payload.status;
                        this.showGameMessage(`Game is now ${payload.status}.`, "info");
                        break;
                    case 'GAME_STOPPED': case 'GAME_OVER_ALL_NUMBERS_CALLED':
                        this.gameStatus = 'stopped';
                        if(payload.finalCalledNumbers) this.calledNumbersHistory = payload.finalCalledNumbers;
                        if(this.calledNumbersHistory.length > 0) this.latestCalledNumber = this.calledNumbersHistory[this.calledNumbersHistory.length - 1];
                        this.showGameMessage(type === 'GAME_STOPPED' ? "Game has been stopped by admin." : "All numbers called! Game Over!", "info", null);
                        this.updateCanClaimPrizeStatus(); // Claims usually disabled when game stops
                        break;
                    case 'WINNER_ANNOUNCEMENT': // General announcement for all players
                        this.showGameMessage(`${payload.playerName} won ${payload.prizeName} (+${payload.coins.toFixed(2)})!`, 'info', 7000);
                        // If this announcement is for a prize *this* player won, their specific 'CLAIM_STATUS_UPDATE' handles individual prize list.
                        // This might also be used by admin to re-announce, or for prizes not directly claimed by player UI.
                        break;
                    case 'PLAYER_CLAIM_SUBMITTED':
                        if (!this.myClaims.find(c => c.claimId === payload.claimId)) {
                             this.myClaims.push({claimId: payload.claimId, prizeName: payload.prizeName, status: payload.status, reason: ''});
                        }
                        this.showGameMessage(`Your claim for ${payload.prizeName} sent to admin.`, "info");
                        break;
                    case 'ERROR': this.showGameMessage(`Server Error: ${payload.message}`, 'error', null); break;
                    case 'INFO': this.showGameMessage(`Server Info: ${payload.message}`, 'info'); break;
                    default: console.warn("Player received unknown WebSocket message type:", data.type);
                }
            },

            // Game Actions & UI Logic
            markNumberOnTickets(numberToMark) {
                this.tickets.forEach(ticket => {
                    let numberExistsOnTicket = false;
                    for (const row of ticket.numbers) { if (row.includes(numberToMark)) { numberExistsOnTicket = true; break; } }
                    if (numberExistsOnTicket && !ticket.marked.includes(numberToMark)) {
                        ticket.marked.push(numberToMark);
                    }
                });
            },
            manualMarkNumber(ticketId, number) {
                if (number === null || this.gameStatus !== 'running') return;
                if (this.autoMarkNumbers) { this.showGameMessage("Auto-mark is ON. Called numbers are marked automatically.", "info"); return; }

                const ticket = this.tickets.find(t => t.id === ticketId);
                if (ticket) {
                    if (this.calledNumbersHistory.includes(number)) {
                        const index = ticket.marked.indexOf(number);
                        if (index > -1) ticket.marked.splice(index, 1);
                        else { ticket.marked.push(number); this.triggerConfetti(); }
                    } else {
                        this.showGameMessage(`Number ${number} has not been called yet! Boogie!`, "error");
                        const boogieCellId = ticketId + '-' + number;
                        this.tempBoogieCells.push(boogieCellId);
                        setTimeout(() => { this.tempBoogieCells = this.tempBoogieCells.filter(id => id !== boogieCellId); }, 1000);
                    }
                }
            },
            toggleAutoMarkBehavior() {
                if (this.autoMarkNumbers) {
                    this.showGameMessage("Auto-marking ENABLED. Called numbers will be marked.", "info");
                    this.calledNumbersHistory.forEach(calledNum => this.markNumberOnTickets(calledNum));
                } else {
                    this.showGameMessage("Auto-marking DISABLED. Mark your tickets manually.", "warning");
                }
            },
            requestNewTicket() {
                if (this.tickets.length >= 5) { this.showGameMessage("Maximum 5 tickets allowed.", "warning"); return; }
                if (this.gameStatus !== 'running') { this.showGameMessage("Can only request tickets while game is running.", "warning"); return; }
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify({ type: 'PLAYER_REQUEST_TICKET', payload: { playerId: this.playerId } }));
                    this.waitingForTicketApproval = true;
                    this.showGameMessage("Requesting new ticket from admin...", "info");
                } else { this.showGameMessage("Not connected to server. Cannot request ticket.", "error"); }
            },
            openClaimModal() {
                if (this.tickets.length === 0) { this.showGameMessage("You have no tickets to claim a prize on.", "warning"); return; }
                if (!this.selectedTicketIdForClaim && this.tickets.length > 0) this.selectedTicketIdForClaim = this.tickets[0].id;
                this.updateAvailablePrizes();
                if (this.$refs.claimModal) this.$refs.claimModal.showModal();
            },
            updateAvailablePrizes() {
                 this.availablePrizesToClaim = this.gameRules.filter(rule => {
                    if (!rule.isActive) return false;
                    // A prize is available if player hasn't already won it or had an approved claim for its name.
                    const hasWonThisPrizeName = this.myPrizes.some(p => p.prizeName === rule.name);
                    const hasApprovedClaimForThisName = this.myClaims.some(c => c.prizeName === rule.name && c.status === 'approved');
                    return !hasWonThisPrizeName && !hasApprovedClaimForThisName;
                });
            },
            prizeAlreadyClaimedOrWon(prizeRuleId) { // Checks if this prize *rule* has been won by the player
                const rule = this.gameRules.find(r => r.id === prizeRuleId);
                if(!rule) return false; // Should not happen if prizeRuleId comes from availablePrizesToClaim
                return this.myPrizes.some(prize => prize.prizeName === rule.name) || // Check against official winnings
                       this.myClaims.some(claim => claim.prizeName === rule.name && claim.status === 'approved'); // Check against approved claims
            },
            submitPrizeClaim(prizeRuleId) {
                if (!this.selectedTicketIdForClaim) { this.showGameMessage("Please select a ticket to claim on.", "warning"); return; }
                const rule = this.gameRules.find(r => r.id === prizeRuleId);
                if (rule && this.socket && this.socket.readyState === WebSocket.OPEN) {
                    const clientTempClaimId = 'claim_' + this.playerId + '_' + prizeRuleId + '_' + Date.now();
                    if (!this.myClaims.find(c => c.prizeName === rule.name && (c.status === 'pending_admin_approval' || c.status === 'approved'))) {
                        this.myClaims.push({claimId: clientTempClaimId, prizeName: rule.name, status: 'pending_admin_approval'});
                    }
                    this.socket.send(JSON.stringify({
                        type: 'PLAYER_CLAIM_PRIZE',
                        payload: { prizeRuleId: prizeRuleId, ticketId: this.selectedTicketIdForClaim }
                    }));
                    // Server will respond with PLAYER_CLAIM_SUBMITTED to confirm receipt and provide official claimId
                    if (this.$refs.claimModal) this.$refs.claimModal.close();
                } else if (!rule) { this.showGameMessage("Selected prize rule not found.", "error");
                } else { this.showGameMessage("Not connected to server. Cannot claim prize.", "error"); }
            },
            updateCanClaimPrizeStatus() {
                this.canClaimPrize = this.gameStatus === 'running' && this.gameRules.some(rule => rule.isActive) && this.tickets.length > 0;
            },

            // Utility Functions
            triggerConfetti() { if (typeof confetti === 'function') confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } }); },
            setTheme(themeName, event = null, closeDropdown = true) { // THEME SELECTOR FUNCTION
                document.documentElement.setAttribute('data-theme', themeName);
                localStorage.setItem('theme', themeName);
                if (closeDropdown && event && event.target) {
                    const anchorElement = event.target;
                    const dropdownRoot = anchorElement.closest('.dropdown');
                    const dropdownTriggerLabel = dropdownRoot?.querySelector('label[tabindex="0"]');
                    setTimeout(() => {
                        if (document.activeElement && dropdownRoot && dropdownRoot.contains(document.activeElement)) {
                            if (typeof document.activeElement.blur === 'function') document.activeElement.blur();
                        }
                        if (dropdownTriggerLabel && typeof dropdownTriggerLabel.blur === 'function') dropdownTriggerLabel.blur();
                    }, 0);
                }
            },
            changeView(viewName) { this.currentView = viewName; this.isDrawerOpen = false; },
            logout() {
                this.showGameMessage("Logging out...", "info", 1500);
                if (this.socket && this.socket.readyState === WebSocket.OPEN) { this.socket.close(); }
                localStorage.removeItem('playerName');
                localStorage.removeItem('roomId');
                // localStorage.removeItem('playerTicket'); // Old, not used for init anymore
                setTimeout(() => { window.location.href = 'player_join.html'; }, 1000);
            },
            showGameMessage(text, type = 'info', duration = 3000) {
                this.gameMessage = text; this.gameMessageType = type;
                if (this.gameMessageTimeout) clearTimeout(this.gameMessageTimeout);
                if (duration !== null) { this.gameMessageTimeout = setTimeout(() => { this.gameMessage = ''; }, duration); }
            }
        }
    }
    </script>
</body>
</html>
